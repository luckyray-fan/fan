# 测试案例

### 研究不同的事件与不同子进程数的关系

##### 测试案例一
- 案例特性: 链接数极少, 但是每个链接的数据发送频率极快.
- 服务端和客户端同一台服务器. 服务器为一台物理机(F5). 内存: 64G. CPU: 2个物理CPU, 24个逻辑CPU, 6核心. CPU信息: Intel(R) Xeon(R) CPU E5-2630 v2 @ 2.60GHz. PHP版本为5.6.
- 服务端: 一个基于Telnet协议的实例, 监听0.0.0.0:19910. 使用Libevent事件机制.
- 客户端: 启动2个客户端, 使用PHP模拟Telnet. 每个客户端都是一个死循环. 每次循环创建一个链接, 执行100次发送"hello world\n"并接收服务器返回信息的任务, 最后断开连接. 测试脚本为Test/test_less_connect_quick_send1(2).php
###### 测试案例一结果
- 服务端一个进程, 测试时间共600秒. CPU占用3.3%, 基本是服务端一个进程所占, 客户端两个进程所耗费可忽略不计. 服务端每个进程占用0.75M内存. 每个客户端进程分别链接了94616次和93703次. QPS为31386. 创建链接,发送消息,接收消息,关闭链接全程无报错.
- 服务端三十二个进程, 测试时间共600秒. CPU占用6.0%, 服务端每个进程占用0.75M内存, 每个客户端进程分别链接了130543次和130032次. QPS为43429. 因为客户端请求数较少, 所以只有2个进程属于运行中, 其他进程都是Sleep. 创建链接,发送消息,接收消息,关闭链接全程无报错.

##### 测试案例二
- 案例特性: 链接数较多, 并且每个链接的数据发送频率较快.
- 服务端和客户端同一台服务器. 服务器为一台物理机(F5). 内存: 64G. CPU: 2个物理CPU, 24个逻辑CPU, 6核心. CPU信息: Intel(R) Xeon(R) CPU E5-2630 v2 @ 2.60GHz. PHP版本为5.6.
- 服务端: 一个基于Telnet协议的实例, 监听0.0.0.0:19910. 使用Libevent事件机制.
- 客户端: 启动1000个客户端, 使用PHP模拟Telnet. PHP脚本先创建1000个链接, 随后进入死循环, 每个循环让1000个客户端像服务器发送"hello world\n", 并接收服务器的返回信息. 测试脚本为Test/test_more_connect_quick_send.php
###### 测试案例二结果
- 服务端一个进程, 测试时间共949秒. CPU占用3%, 服务端内存占用各11M. 共发送请求20804000个, 接收回复20804000个. QPS为21922. 创建链接,发送消息,接收消息,关闭链接全程无报错.
- 服务端四个进程, 测试时间共670秒. CPU占用3%, 服务端内存占用各14M. 共发送请求13921000个, 接收回复13921000个. QPS为20777. 创建链接,发送消息,接收消息,关闭链接全程无报错.
- 服务端三十二个进程, 测试时间共600秒. CPU占用2%,  服务端每个进程占用1M-1.25M内存. 共发送请求10874000个, 接收回复10874000个. QPS为18123. 创建链接,发送消息,接收消息,关闭链接全程无报错.

##### 测试案例三
- 案例特性: 链接数极少, 但是每个链接的数据发送频率极快.
- 服务端和客户端同一台服务器.服务器为家用HPGen8(CPU:Intel Celeron G1610T, 内存2G), 虚拟机CentOS7. PHP版本为5.6.
- 服务端: 一个基于Telnet协议的实例, 监听0.0.0.0:19910
- 客户端: 启动2个客户端, 使用PHP模拟Telnet. 每个客户端都是一个死循环. 每次循环创建一个链接, 执行100次发送"hello world\n"并接收服务器返回信息的任务, 最后断开连接. 测试脚本为Test/test_less_connect_quick_send1(2).php
###### 测试案例三结果
- 服务端一个进程, 使用Select轮询机制: 测试时间共76314秒. CPU一直100%, 服务端一个进程和客户端两个进程, 各占三分之一的CPU. 每个客户端进程分别链接了6555971次和7218005次. QPS为18049. 创建链接,发送消息,接收消息,关闭链接全程无报错.
- 服务端一个进程, 使用Libevent事件机制: 测试时间共20136秒. CPU占用70%, 服务端一个进程占45%, 客户端两个进程所耗费各占13%. 每个客户端进程分别链接了1316448次和1329669次. QPS为13141. 创建链接,发送消息,接收消息,关闭链接全程无报错.
- 服务端二个进程, 使用Select轮询机制: QPS略低于(1), 因为CPU已经满负荷, 多起进程并不能提升性能, 反而会成为拖累.
- 服务端二个进程, 使用Libevent事件机制: 测试时间共42576秒. CPU占用75%, 服务端两个进程占48%, 客户端两个进程所耗费各占27%. 每个客户端进程分别链接了2345267次和2366066次. QPS为11065. 创建链接,发送消息,接收消息,关闭链接全程无报错.

##### 测试案例四:
- 案例特性: 链接数较多, 并且每个链接的数据发送频率较快.
- 服务端和客户端同一台服务器.服务器为家用HPGen8(CPU:Intel Celeron G1610T, 内存2G), 虚拟机CentOS7. PHP版本为5.6.
- 服务端: 一个基于Telnet协议的实例, 监听0.0.0.0:19910.
- 客户端: 启动1000个客户端, 使用PHP模拟Telnet. PHP脚本先创建1000个链接, 随后进入死循环, 每个循环让1000个客户端像服务器发送"hello world\n", 并接收服务器的返回信息. 测试脚本为Test/test_more_connect_quick_send.php
###### 测试案例四结果
- 服务端一个进程, 使用Select轮询机制: 测试时间共19943秒. CPU占用53%, 服务端一个进程各占48%, 客户端一个进程所耗费各占5%. 服务端内存占用各11M. 共发送请求17701931个, 接收回复17701931个. QPS为887. 创建链接,发送消息,接收消息,关闭链接全程无报错.
- 服务端一个进程, 使用Libevent事件机制: 测试时间共17231秒. CPU占用52%, 服务端一个进程占35%, 客户端一个进程所耗费各占27%. 服务端内存占用7.5M. 共发送请求121732543个, 接收回复121732543个. QPS为7064. 创建链接,发送消息,接收消息,关闭链接全程无报错.
- 服务端二个进程, 使用Select轮询机制: 测试时间共32752秒. CPU占用65%, 服务端两个进程各占54%, 客户端一个进程所耗费各占11%. 服务端内存占用各6M. 共发送请求44236944个, 接收回复44236944个. QPS为1305. 创建链接,发送消息,接收消息,关闭链接全程无报错.
- 服务端二个进程, 使用Libevent事件机制: 测试时间共10403秒. CPU占用54%, 服务端两个进程各占16%, 客户端一个进程所耗费各占22%. 服务端内存占用各6M. 共发送请求71648828个, 接收回复71648828个. QPS为6887. 创建链接,发送消息,接收消息,关闭链接全程无报错.

#### 结论
- 在CPU已经高负荷或满负荷运行下, 增加进程数并不能增加QPS, 并且可能起反作用.
- 链接数极少的情况下, Libevent的事件机制并不能有效的增加QPS, 系统自带的Select轮询机制可能会更好.
- 链接数极少的情况下, 内存占用也极少.
- 链接数越多, Libevent事件机制的优势越大, 链接数越少, Select轮询机制越占优势.
- 链接数的增加, 会提高内存的占用. 发送消息的频率越高, 会提高CPU的使用率.
